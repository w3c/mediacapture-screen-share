<!DOCTYPE html>
<html lang="en-us">
  <head>
    <link href="screenshare.css" rel="stylesheet" type="text/css">
    <title>
      Screen Capture
    </title>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <script class="remove" src="https://www.w3.org/Tools/respec/respec-w3c-common" type=
    "text/javascript">
    //<![CDATA[
    <!-- keep this comment: what a frightening kludge -->
    //]]>
    </script>
    <script class="remove" src="screenshare.js" type="text/javascript">
    //<![CDATA[
    <!-- keep this comment -->
    //]]>
    </script>
  </head>
  <body>
    <section id="abstract">
      <p>
        This document defines how a user's display, or parts thereof, can be used as the source of
        a media stream using getDisplayMedia, an extension to the Media Capture API
        [[!GETUSERMEDIA]].
      </p>
    </section>
    <section id="sotd">
      <p>
        This document is not complete. It is subject to major changes and, while early
        experimentations are encouraged, it is therefore not intended for implementation.
      </p>
    </section>
    <section class="informative" id="intro">
      <h2>
        Introduction
      </h2>
      <p>
        This document describes an extension to the Media Capture API [[GETUSERMEDIA]] that enables
        the acquisition of a user's display, or part thereof, in the form of a video stream. This
        enables a number of applications, including screen sharing using WebRTC [[WEBRTC]].
      </p>
      <p>
        This feature has signficant security implications. Applications that use this API to access
        information that is displayed to users could access confidential information from other
        origins if that information is under the control of the application. This includes content
        that would otherwise be inaccessible due to the protections offered by the user agent
        sandbox.
      </p>
      <p>
        This document concerns itself primarily with the capture of video, but the general
        mechanisms defined here could be extended to other types of media, of which audio
        [[GETUSERMEDIA]] and depth [[MEDIACAPTURE-DEPTH]] are currently defined.
      </p>
    </section>
    <section id="conformance">
      <p>
        This specification defines conformance criteria that apply to a single product: the
        <dfn data-lt="user agents">user agent</dfn> that implements the interfaces that it
        contains.
      </p>
      <p>
        Implementations that use ECMAScript [[ECMA-262]] to implement the APIs defined in this
        specification must implement them in a manner consistent with the ECMAScript Bindings
        defined in the Web IDL specification [[!WEBIDL]], as this specification uses that
        specification and terminology.
      </p>
    </section>
    <section>
      <h2>
        Example
      </h2>
      <p>
        The following example demonstrates a request for display capture using the
        <code>navigator.getDisplayMedia</code> method defined in this document.
      </p>
      <pre class="example highlight">try {
  let mediaStream = await navigator.getDisplayMedia({video:true});
  videoElement.srcObject = mediaStream;
} catch (e) {
  console.log('Unable to acquire screen capture: ' + e);
}</pre>
    </section>
    <section>
      <h2>
        Terminology
      </h2>
      <p>
        This document uses the definition of <code><dfn><a href=
        "https://w3c.github.io/mediacapture-main/#mediastreamtrack">MediaStreamTrack</a></dfn></code>,
        and <code><dfn><a href=
        "https://w3c.github.io/mediacapture-main/#interface-definition">ConstrainablePattern</a></dfn></code>
        from [[!GETUSERMEDIA]].
      </p>
      <p>
        Screen capture encompasses the capture of several different types of screen-based surfaces.
        Collectively, these are referred to as <dfn data-lt="display surface">display
        surfaces</dfn>, of which this document defines the following types:
      </p>
      <ul>
        <li>A <dfn>monitor</dfn> <a>display surface</a> represents a physical display. Some systems
        have multiple <a>monitor</a>s, which can be identified separately. Multiple <a>monitor</a>s
        might also be aggregated into as a single logical <a>monitor</a>. An aggregated <a>display
        surface</a> is captured as a single <code><a>MediaStreamTrack</a></code>.
        </li>
        <li>A <dfn data-lt="windows">window</dfn> <a>display surface</a> is a single contiguous
        surface that is used by a single application.
        </li>
        <li>A single application might have several <a>windows</a> available to it, and those can
        be aggregated into a single <dfn>application</dfn> surface, representing all the windows
        available to that application and therefore presented as a single
        <code><a>MediaStreamTrack</a></code>.
        </li>
        <li>A <dfn>browser</dfn> <a>display surface</a> is the rendered form of a single document.
        This is not strictly limited to HTML [[HTML5]] documents, though the discussion in this
        document will address some specific concerns with the capture of HTML.
        </li>
      </ul>
      <p>
        This document draws a distinction between two variants of each type of display surface:
      </p>
      <ul>
        <li>A <dfn data-lt="logical display surfaces">logical display surface</dfn> is the surface
        that an operating system makes available to an application for the purposes of rendering.
        </li>
        <li>a <dfn>visible display surface</dfn> is the portion of a <a>logical display surface</a>
        that is rendered to a <a>monitor</a>.
        </li>
      </ul>
      <p>
        Some operating systems permit windows from different applications to occlude other windows,
        in whole or part, so the <a>visible display surface</a> is a strict subset of the
        <a>logical display surface</a>.
      </p>
      <p>The terms <dfn>permission</dfn>, <dfn>retrieve the permission state</dfn>,
      <dfn id="prompt-the-user-to-choose">prompt the user to choose</dfn>, and
      <dfn id="create-permission">create a permission storage entry</dfn> are
      defined in [[!permissions]].</p>
      <p>The <dfn>devicechange</dfn> event is defined in [[GETUSERMEDIA]] Section 9.2, 
      the <dfn>MediaTrackSupportedConstraints</dfn> dictionary is defined in [[GETUSERMEDIA]] Section 4.3.4,
      the <dfn>MediaTrackConstraintSet</dfn> dictionary is defined in [[GETUSERMEDIA]] Section 4.3.6, and
      the <dfn>MediaTrackSettings</dfn> dictionary is defined in [[GETUSERMEDIA]] Section 4.3.7.</p>
    </section>
    <section>
      <h2>
        Capturing Displayed Media
      </h2><!--
      Interesting Links

      https://bugzilla.mozilla.org/show_bug.cgi?id=742832

      http://www.chromium.org/developers/design-documents/extensions/proposed-changes/apis-under-development/webrtc-tab-content-capture

      https://docs.google.com/document/d/1-vFghorm8zDCeyg2Yk6kKFT-16GU1Ow1b1bor_jCqD8/edit
      -->
      <p>
        Capture of displayed media is enabled through the addition of a new
        <code><a>getDisplayMedia</a></code> method on the <code><a>Navigator</a></code>
        interface, that is similar to <code><dfn><a href=
        "https://w3c.github.io/mediacapture-main/#local-content">getUserMedia</a></dfn></code>
        [[!GETUSERMEDIA]].
      </p>
      <div class="note">
        <p>
          Though all constraints are supported for display device capture, not all constraints will
          have an effect. Usually, this is because a display device cannot alter its behavior in a
          way that the constraint implies, just as a video camera cannot alter <a href=
          "https://w3c.github.io/mediacapture-main/#def-constraint-volume">volume</a>.
        </p>
        <p>
          For instance, it is unlikely that setting the following constraints will have any useful
          effect (other than an <a href=
          "https://w3c.github.io/mediacapture-main/#event-mediastreamtrack-overconstrained">overconstrained</a>
          error): <a href=
          "https://w3c.github.io/mediacapture-main/#def-constraint-aspectratio">aspectRatio</a>,
          <a href=
          "https://w3c.github.io/mediacapture-main/#def-constraint-facingmode">facingMode</a>, and
          <a href=
          "https://w3c.github.io/mediacapture-main/#def-constraint-echocancellation">echoCancellation</a>.
        </p>
        <p>
          See <a href="#deviceId"></a> for information on the <a href=
          "https://w3c.github.io/mediacapture-main/#def-constraint-deviceid">deviceId</a> and
          <a href="https://w3c.github.io/mediacapture-main/#def-constraint-groupId">groupId</a>
          constraints.
        </p>
      </div>
      <section>
        <h2>
          <dfn>Navigator</dfn> Additions
        </h2>
        <pre class="idl">partial interface Navigator {
    Promise&lt;MediaStream&gt; getDisplayMedia (optional MediaStreamConstraints constraints);
};</pre>
        <dl data-link-for="Navigator" data-dfn-for="Navigator" class="methods">
          <dt>
            <code><dfn data-dfn-for="getDisplayMedia">getDisplayMedia</dfn></code>
          </dt>
          <dd>
            <p>Prompts the user for permission to live-capture their display.</p>
            <p>
              This method is similar to <code><a>getUserMedia</a></code>, except that it
              acquires media from one display device chosen by the end-user each time.
              The user agent MUST let the end-user choose which display surface to share
              out of all available choices every time, and MUST NOT use
              <code>constraints</code> to limit that choice. Instead,
              <code>constraints</code> MUST be applied to the media chosen by the user,
              only after they have made their selection. This prevents an application
              from influencing the selection of sources, see <a href="#constraints"></a>
              for details.
            </p>
            <p>
              In addition to drawing from a different set of sources and requiring user selection,
              <code><a>getDisplayMedia</a></code> also differs from
              <code><a>getUserMedia</a></code> in that "granted" permissions cannot be persisted.
            </p>
            <p>When the <code><dfn>getDisplayMedia()</dfn></code>
            method is called, the User Agent MUST run the following
            steps:</p>
            <ol>
              <li>
                <p>Let <var>constraints</var> be the method's first
                argument.</p>
              </li>
              <li>
                <p>For each member
                <a href="https://heycam.github.io/webidl/#dfn-present">present</a>
                in <var>constraints</var> whose value, <var>value</var>, is a
                dictionary, run the following steps:</p>
                <ol>
                  <li>
                    <p>If <var>value</var> contains a member named <code>advanced</code>,
                    return a promise <a>rejected</a> with a newly
                    <a data-link-for="exception" data-lt="create">created</a>
                    <code>TypeError</code>.</p>
                  </li>
                  <li>
                    <p>If <var>value</var> contains a member which in turn
                    is a dictionary containing a member named either
                    <code>min</code> or <code>exact</code>, return a promise
                    <a>rejected</a> with a newly
                    <a data-link-for="exception" data-lt="create">created</a>
                    <code>TypeError</code>.</p>
                  </li>
                </ol>
              </li>
              <li>
                <p>Let <var>requestedMediaTypes</var> be the set of media
                types in <var>constraints</var> with either a dictionary
                value or a value of <code>true</code>.</p>
              </li>
              <li>
                <p>If <var>requestedMediaTypes</var> is the empty set, set
                <var>requestedMediaTypes</var> to a set containing
                <code>"video"</code>.</p>
              </li>
              <li>
                <p>If the <a>current settings object</a>'s <a>responsible
                  document</a> is NOT <a data-cite=
                    "!HTML52/browsers.html#fully-active">fully active</a>, return
                  a promise <a>rejected</a> with a
                  <code><a>DOMException</a></code> object whose
                  <code><a>name</a></code> attribute has the value
                  <code>InvalidStateError</code>.</p>
              </li>
              <li>
                <p>If the <a>current settings object</a>'s <a>responsible
                  document</a> is NOT <a>allowed to use</a> the feature
                indicated by Feature Policy [TBD],
                return a promise <a>rejected</a> with a
                <code><a>DOMException</a></code> object whose
                <code><a>name</a></code> attribute has the value
                <code>SecurityError</code>.</p>
              </li>
              <li>
                <p>Let <var>originIdentifier</var> be the <a>current settings
                  object</a>'s <a data-cite=
                    "!HTML52/webappapis.html#responsible-browsing-context">responsible
                    browsing context</a>'s [[!HTML52]] <a data-cite=
                      "!HTML52/browsers.html#top-level-browsing-context">top-level
                      browsing context</a>'s <a data-cite=
                        "!HTML52/browsers.html#active-document">active document</a>'s
                      origin.</p>
              </li>
              <li>
                <p>If the <a>current settings object</a>'s origin is
                different from <var>originIdentifier</var>, set
                <var>originIdentifier</var> to the result of combining
                <var>originIdentifier</var> and the <a>current settings
                  object</a>'s origin.</p>
              </li>
              <li>
                <p>Let <var>p</var> be a new promise.</p>
              </li>
              <li>
                <p>Run the following steps in parallel:</p>
                <ol>
                  <li>
                    <p>For each media type <var>T</var> in
                    <var>requestedMediaTypes</var>,</p>
                    <ol>
                      <li>
                        <p>If no sources of type <var>T</var> are available,
                        <a>reject</a> <var>p</var> with a new
                        <code><a>DOMException</a></code> object whose
                        <code><a>name</a></code> attribute has the value
                        <code>NotFoundError</code>.</p>
                      </li>
                      <li>
                        <p><a>Retrieve the permission state</a> for obtaining
                        sources of type <var>T</var> in the current browsing
                        context. If the permission state is "denied", jump to
                        the step labeled <em>PermissionFailure</em> below.</p>
                      </li>
                    </ol>
                  </li>
                  <li>
                    <p>Optionally, e.g., based on a previously-established
                    user preference, for security reasons, or due to platform
                    limitations, jump to the step labeled <em>Permission
                      Failure</em> below.</p>
                  </li>
                  <li>
                    <p>For the origin identified by
                    <var>originIdentifier</var>, <a>prompt the user to choose</a>
                    a display device, with a PermissionDescriptor named
                    <code>"display"</code>, resulting in a set of
                    provided media.</p>
                    <p>The provided media MUST include precisely one track of
                    each media type in <var>requestedMediaTypes</var>.
                    The devices chosen MUST be the ones determined by the user.
                    Once selected, the source of a
                    <code><a>MediaStreamTrack</a></code> MUST NOT change.</p>
                    <p>User Agents are encouraged to warn users against sharing
                    <a>browser</a> display devices as well as <a>monitor</a>
                    display devices where browser windows are visible, or
                    otherwise try to discourage their selection on the basis
                    that these represent a significantly higher risk when shared.</p>
                    <p>If the result of the request is "granted", then for
                    each device that is sourcing the provided media, using
                    a stable and private id for the device, <var>deviceId</var>,
                    set [[\devicesLiveMap]]<var>[deviceId]</var> to
                    <code>true</code>, if it isn’t already <code>true</code>,
                    and set the
                    [[\devicesAccessibleMap]]<var>[deviceId]</var> to
                    <code>true</code>, if it isn’t already
                    <code>true</code>.</p>
                    <p>The User Agent MUST NOT
                    <a href="#create-permission">create a permission storage entry</a>
                    with a value of "granted".
                    </p>
                    <p>If the result is "denied", jump to the step labeled
                    <em>Permission Failure</em> below. If the user never
                    responds, this algorithm stalls on this step.</p>
                    <p>If the user grants permission but a hardware error
                    such as an OS/program/webpage lock prevents access,
                    <a>reject</a> <var>p</var> with a new
                    <code><a>DOMException</a></code> object whose
                    <code><a>name</a></code> attribute has the value
                    <code>NotReadableError</code> and abort these steps.</p>
                    <p>If the result is "granted" but device access fails for
                    any reason other than those listed above, <a>reject</a>
                    <var>p</var> with a new <code><a>DOMException</a></code>
                    object whose <code><a>name</a></code> attribute has the
                    value <code>AbortError</code> and abort these steps.</p>
                  </li>
                  <li>
                    <p>Let <var>stream</var> be the
                    <code><a>MediaStream</a></code> object for which the user
                    granted permission.</p>
                  </li>
                  <li>
                    <p>Run the <a href=
                    "https://w3c.github.io/mediacapture-main/#dfn-applyconstraints-algorithm">
                    <dfn>ApplyConstraints algorithm</dfn></a> on all
                    tracks in <var>stream</var> with the appropriate
                    constraints. Should this fail, let <var>failedConstraint</var>
                    be the result of the algorithm that failed, and let
                    <var>message</var> be either <code>undefined</code> or an
                    informative human-readable message, and then <a>reject</a>
                    <var>p</var> with a new <code>OverconstrainedError</code>
                    created by calling
                    <code>OverconstrainedError(<var>failedConstraint</var>,
                    <var>message</var>)</code>.</p>
                  </li>
                  <li>
                    <p><a>Resolve</a> <var>p</var> with <var>stream</var> and
                    abort these steps.</p>
                  </li>
                  <li>
                    <p><em>Permission Failure</em>: <a>Reject</a>
                    <var>p</var> with a new <code><a>DOMException</a></code>
                    object whose <code><a>name</a></code> attribute has the
                    value <code>NotAllowedError</code>.</p>
                  </li>
                </ol>
              </li>
              <li>
                <p>Return <var>p</var>.</p>
              </li>
            </ol>
          </dd>
          <div class="note">
            <p>
            Min and exact constraints are disallowed by getDisplayMedia().
            The max constraint type lets a web application provide a maximum envelope
            for constrainable properties like width and height, should the
            end-user resize a <a>window</a> or <a>browser</a> surface while it
            is being captured.
            </p>
          </div>
        </dl>
      </section>
      <section>
        <h2 id="hidden-display-surfaces">
          Closed and Minimized Display Surfaces
        </h2>
        <p>
          A <a>display surface</a> that is being shared may temporarily or permanently become
          inaccessible to the application because of actions taken by the operating system or user
          agent. What makes a <a>display surface</a> considered inaccesible is outside the scope
          of this specification, but examples MAY include a <a>monitor</a> disconnecting or an
          <a>application</a>, <a>window</a> or <a>browser</a> closing or becoming minimized.
        </p>
        <p>
          When <a>display surface</a> enters an inaccessible state that is not necessarily
          permanent, the user agent MUST queue a task that <a>sets the muted state</a> of the
          corresponding media track to <code>true</code>.
        </p>
        <p>
          When <a>display surface</a> exits an inaccessible state and becomes accessible, the
          user agent MUST queue a task that <a>sets the muted state</a> of the corresponding
          media track to <code>false</code>.
        </p>
        <p>
          When a <a>display surface</a> enters an inaccessible state that is permanent (such as
          the source application terminating), the user agent MUST queue a task that <a>ends</a>
          the corresponding media track.
        </p>
        <p>
          A stream that was just returned by <code><a>getDisplayMedia</a></code> MAY contain
          tracks that are muted by default. Audio and video tracks belonging to the same stream
          MAY be muted/unmuted independently of one another.
        </p>
      </section>
      <section>
        <h2 id="constraints">
          Constraining Display Surface Selection
        </h2>
        <p class="fingerprint">
          Not accepting constraints for source selection means that
          <code><a>getDisplayMedia</a></code> only provides fingerprinting surface that exposes
          whether audio, video or audio and video display sources are present. <img alt=
          "(This is a fingerprinting vector.)" src="images/fingerprint.png" width="15" height="21">
        </p>
      </section>
      <section>
        <h2 id="display-constraints">
          New Constrainable Properties for Captured Display Surfaces
        </h2>
        <p>
          Following new <a href="https://www.w3.org/TR/mediacapture-streams/#defining-a-new-constrainable-property">
          Constrainable Properties</a> are defined that allow an application to observe the properties
          of the selected <a>display surface</a>. Since the source of media cannot be changed after a
          <code>MediaStreamTrack</code> has been returned and constraints do not affect the
          selection of <a>display surfaces</a>, these constrainable properties cannot be changed by an
          application.
        </p>
        <p>
          The <code><a data-link-for="MediaTrackConstraintSet">displaySurface</a></code> constraint
          allows an application to observe the type of <a>display surface</a> that is being
          captured.
        </p>
        <p>
          The <code><a data-link-for="MediaTrackConstraintSet">logicalSurface</a></code> constraint
          allows an application to observe whether the surface that is captured is a <a>logical
          display surface</a>, rather than the <a>visible display surface</a>.
        </p>
        <p>
          The <code><a data-link-for="MediaTrackConstraintSet">cursor</a></code> constraint
          allows an application to specify if the cursor should be included in the captured
          display.
        </p>
        <section>
          <h2>
            Extensions to <a class="idlType">MediaTrackSupportedConstraints</a>
          </h2>
          <p>
            <a href="https://www.w3.org/TR/mediacapture-streams/#idl-def-MediaTrackSupportedConstraints">
            MediaTrackSupportedConstraints</a> is extended here with the list of constraints that a User
            Agent recognizes.
          </p>
          <pre class="idl">partial dictionary MediaTrackSupportedConstraints {
             boolean displaySurface = true;
             boolean logicalSurface = true;
             boolean cursor = true;
};</pre>
          <dl data-link-for="MediaTrackSupportedConstraints" data-dfn-for="MediaTrackSupportedConstraints"
          class="dictionary-members">
            <dt>
              <dfn><code>displaySurface</code></dfn> of type <span class=
              "idlMemberType"><a>boolean</a></span>, defaulting to <code>true</code>
            </dt>
            <dd>
              <p>
                Whether <code><a>displaySurface</a></code> constraint is recognized.
              </p>
            </dd>
            <dt>
              <dfn><code>logicalSurface</code></dfn> of type <span class=
              "idlMemberType"><a>boolean</a></span>, defaulting to <code>true</code>
            </dt>
            <dd>
              <p>
                Whether <code><a>logicalSurface</a></code> constraint is recognized.
              </p>
            </dd>
            <dt>
              <dfn><code>cursor</code></dfn> of type <span class=
              "idlMemberType"><a>boolean</a></span>, defaulting to <code>true</code>
            </dt>
            <dd>
              <p>
                Whether <code><a>cursor</a></code> constraint is recognized.
              </p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            Extensions to <a class="idlType">MediaTrackConstraintSet</a>
          </h2>
          <p>
            <a href="https://www.w3.org/TR/mediacapture-streams/#idl-def-MediaTrackConstraintSet">
            MediaTrackConstraintSet</a> is used for reading the current status of constraints.
          </p>
          <pre class="idl">partial dictionary MediaTrackConstraintSet {
             ConstrainDOMString displaySurface;
             ConstrainBoolean   logicalSurface;
             ConstrainDOMString   cursor;
};</pre>
          <dl data-link-for="MediaTrackConstraintSet" data-dfn-for="MediaTrackConstraintSet" class=
          "dictionary-members">
            <dt>
              <dfn><code>displaySurface</code></dfn> of type <span class=
              "idlMemberType"><a>ConstrainDOMString</a></span>
            </dt>
            <dd>
              <p>
                The type of <a>display surface</a> that is being captured. This assumes values from
                the <code><a>DisplayCaptureSurfaceType</a></code> enumeration.
              </p>
            </dd>
            <dt>
              <dfn><code>logicalSurface</code></dfn> of type <span class=
              "idlMemberType"><a>ConstrainBoolean</a></span>
            </dt>
            <dd>
              <p>
                A value of <code>true</code> indicates capture of a <a>logical display surface</a>;
                a value of <code>false</code> indicates a capture of a <a>visible display
                surface</a>.
              </p>
            </dd>
            <dt>
               <dfn><code>cursor</code></dfn> of type <span class=
               "idlMemberType"><a>ConstrainDOMString</a></span>
            </dt>
            <dd>
              <p>
                Assumes values from the <code><a>CursorCaptureConstraint</a></code> enumeration that
                determines if and when the cursor is included in the captured display surface.
              </p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            Extensions to <a class="idlType">MediaTrackSettings</a>
          </h2>
          <p>
            When the <a href="https://www.w3.org/TR/mediacapture-streams/#constrainable-interface">getSettings()</a>
            method is invoked on a video stream track, the user agent must return the extended
            <a href="https://www.w3.org/TR/mediacapture-streams/#media-track-settings">MediaTrackSettings</a>
            dictionary, representing the current status of the underlying user agent.
          </p>
          <pre class="idl">partial dictionary MediaTrackSettings {
             DOMString displaySurface;
             boolean   logicalSurface;
             DOMString   cursor;
};</pre>
          <dl data-link-for="MediaTrackSettings" data-dfn-for="MediaTrackSettings" class=
          "dictionary-members">
            <dt>
              <dfn><code>displaySurface</code></dfn> of type <span class=
              "idlMemberType"><a>DOMString</a></span>
            </dt>
            <dd>
              <p>
                The type of <a>display surface</a> that is being captured. This assumes values from
                the <code><a>DisplayCaptureSurfaceType</a></code> enumeration.
              </p>
            </dd>
            <dt>
              <dfn><code>logicalSurface</code></dfn> of type <span class=
              "idlMemberType"><a>boolean</a></span>
            </dt>
            <dd>
              <p>
                A value of <code>true</code> indicates capture of a <a>logical display surface</a>;
                a value of <code>false</code> indicates a capture capture of a <a>visible display
                surface</a>.
              </p>
            </dd>
            <dt>
               <dfn><code>cursor</code></dfn> of type <span class=
               "idlMemberType"><a>DOMString</a></span>
            </dt>
            <dd>
              <p>
                Assumes values from the <code><a>CursorCaptureConstraint</a></code> enumeration that
                determines if and when the cursor is included in the captured display surface.
              </p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            <dfn>DisplayCaptureSurfaceType</dfn>
          </h2>
          <p>
            The <code><a>DisplayCaptureSurfaceType</a></code> enumeration describes the different
            types of display surface.
          </p>
          <pre class="idl">enum DisplayCaptureSurfaceType {
    "monitor",
    "window",
    "application",
    "browser"
};</pre>
          <table data-link-for="DisplayCaptureSurfaceType" data-dfn-for="DisplayCaptureSurfaceType"
          class="simple">
            <tbody>
              <tr>
                <th colspan="2">
                  Enumeration description
                </th>
              </tr>
              <tr>
                <td>
                  <dfn><code id="idl-def-DisplayCaptureSurfaceType.monitor">monitor</code></dfn>
                </td>
                <td>
                  a <a>monitor</a> <a>display surface</a>, physical display, or collection of
                  physical displays
                </td>
              </tr>
              <tr>
                <td>
                  <dfn><code id="idl-def-DisplayCaptureSurfaceType.window">window</code></dfn>
                </td>
                <td>
                  a <a>window</a> <a>display surface</a>, or single application window
                </td>
              </tr>
              <tr>
                <td>
                  <dfn><code id=
                  "idl-def-DisplayCaptureSurfaceType.application">application</code></dfn>
                </td>
                <td>
                  an <a>application</a> <a>display surface</a>, or entire collection of windows for
                  an application
                </td>
              </tr>
              <tr>
                <td>
                  <dfn><code id="idl-def-DisplayCaptureSurfaceType.browser">browser</code></dfn>
                </td>
                <td>
                  a <a>browser</a> <a>display surface</a>, or single browser window
                </td>
              </tr>
            </tbody>
          </table>
        </section>
        <section>
          <h2>
            <dfn>CursorCaptureConstraint</dfn>
          </h2>
          <p>
            The <code><a>CursorCaptureConstraint</a></code> enumerates the conditions
            under which the cursor is captured.
          </p>
          <pre class="idl">enum CursorCaptureConstraint {
    "never",
    "always",
    "motion"
};</pre>
          <table data-link-for="CursorCaptureConstraint" data-dfn-for="CursorCaptureConstraint"
          class="simple">
            <tbody>
              <tr>
                <th colspan="2">
                  Enumeration description
                </th>
              </tr>
              <tr>
                <td>
                  <dfn><code id="idl-def-CursorCaptureConstraint.never">never</code></dfn>
                </td>
                <td>
                  a <a>never</a> cursor capture constraint omits the cursor from the captured display surface.
                </td>
              </tr>
              <tr>
                <td>
                  <dfn><code id="idl-def-CursorCaptureConstraint.always">always</code></dfn>
                </td>
                <td>
                  a <a>always</a> cursor capture constraint includes the cursor in the captured display surface.
                </td>
              </tr>
              <tr>
                <td>
                  <dfn><code id=
                  "idl-def-CursorCaptureConstraint.motion">motion</code></dfn>
                </td>
                <td>
                  a <a>motion</a> cursor capture constraint includes the cursor in the captured display
                  surface when the cursor/pointer is moved. The captured cursor is removed when there
                  is no further movement of the pointer/cursor for certain period of time, as determined
                  by the <a>user agent</a>.
                </td>
              </tr>
            </tbody>
          </table>
        </section>
      </section>
      <section>
        <h2 id="deviceId">
          Device Identifiers
        </h2>
        <p>
          Each potential source of capture is treated by this API as a discrete media source.
          However, display capture sources MUST NOT be enumerated by <code><a href=
          "https://w3c.github.io/mediacapture-main/#widl-MediaDevices-enumerateDevices-Promise-sequence-MediaDeviceInfo">
          enumerateDevices</a></code>, since this would reveal too much information about the host
          system.
        </p>
        <p>
          Display capture sources therefore cannot be selected with the <code>deviceId</code>
          constraint, since this would allow applications to influence selection; setting
          <code>deviceId</code> constraint can only cause the resulting
          <code><a>MediaStreamTrack</a></code> to become overconstrained.
        </p>
        <p>
          A display capture source is represented in the <code><a>MediaStreamTrack</a></code> API
          as having <code>deviceId</code> and <code>groupId</code> attributes that are randomized
          each time a <code><a>MediaStreamTrack</a></code> is connected. These values cannot
          duplicate any existing values.
        </p>
        <div class="note">
          <p>
          This exposed deviceId identifier is not to be confused with the stable
          and private id of the same name used in algorithms to implement privacy
          indicators.
          </p>
        </div>
      </section>
      <section>
        <h2 id="fullscreen">
          Fullscreen Rendering considerations
        </h2>
          <p><i>This section is non-normative.</i></p>
          <p>
            For applications that support full screen rendering such as powerpoint applications,
            the decision of the display surface that gets captured while in fullscreen mode is 
            specific to the user agent implementation. A user agent MAY choose to switch from 
            capture of a window to the fullscreen when the associated application goes 
            fullscreen. For consistency reasons, an user agent must ensure that the display surface 
            captured in fullscreen mode be unambiguously mapped to the application/window where 
            the action was triggered in the first place. This might be achieved by ensuring that 
            this transition is only made when the captured window has focus before the transition.
          </p>
          <p>
            The choice of <code><a>DisplayCaptureSurfaceType</a></code> and 
            <code><a data-link-for="MediaTrackConstraintSet">logicalSurface</a></code> setting 
            may further influence what gets captured. For example, when an application/window 
            is triggered to go fullscreen with the
            <code><a data-link-for="MediaTrackConstraintSet">logicalSurface</a></code> value 
            of false and the DisplayCaptureSurfaceType of "monitor", the choice of the "monitor" 
            <a>visible display surface</a> selected for capture is solely left to the user agent, 
            especially when there are multiple options available.
          </p> 
      </section>
    </section>
    <section>
      <h1>Privacy Indicator Requirements</h1>
      <p>This specification extends the <a href=
        "https://w3c.github.io/mediacapture-main/#privacy-indicator-requirements">
        Privacy Indicator Requirements</a> of
      <code><a>getUserMedia</a></code> to include <code><a>getDisplayMedia</a></code>.</p>
      <p>References in this specification to [[\devicesLiveMap]],
      [[\devicesAccessibleMap]], and [[\kindsAccessibleMap]] refer to the
      definitions already created to support Privacy Indicator Requirements for
      <code><a>getUserMedia</a></code>.</p>
      <p>For each <var>kind</var> of device that
      <code><a>getDisplayMedia</a></code> exposes, using a stable and private id
      for the device, <var>deviceId</var>, set <var>kind</var>
      to <code>"Display"</code> + <var>kind</var>, and do the following:
      <ul>
        <li>Define <var>any&lt;kind&gt;Accessible</var> (e.g.
          <var>anyDisplayVideoAccessible</var>) as the
          logical OR of the [[\kindsAccessibleMap]]<var>[kind]</var> value and all
          the [[\devicesAccessibleMap]]<var>[deviceId]</var> values for devices of
          that kind, and initialize all values to <code>false</code>.
        </li>
        <li>Define <var>any&lt;kind&gt;Accessible</var> (e.g.
          <var>anyDisplayVideoAccessible</var>) as the
          logical OR of the [[\kindsAccessibleMap]]<var>[kind]</var> value and all
          the [[\devicesAccessibleMap]]<var>[deviceId]</var> values for devices of
          that kind, and initialize all values to <code>false</code>.
        </li>
        <li>Define any<var>&lt;kind&gt;Live</var> (e.g.
          <var>anyDisplayVideoLive</var>) to be the logical OR of all the
          [[\devicesLiveMap]]<var>[deviceId]</var> values for devices of that
          kind.
        </li>
      </ul>
      <p>Then, given the new definitions above, the requirements on the User
      Agent are those specified in <a href=
        "https://w3c.github.io/mediacapture-main/#privacy-indicator-requirements">
        Privacy Indicator Requirements</a> of
      <code><a>getUserMedia</a></code>.</p>
      <div class="note">
        <p>
        Even though there's a single permission descriptor for getDisplayMedia,
        the above definitions distinguish by kind to enable user agents
        to implement privacy indicators that show the end-user the specific kinds
        of display sources that are being shared at any point.
        </p>
      </div>
      <div class="note">
        <p>
        Since this specification forbids user agents from persisting "granted"
        permissions, only the "Live" indicators are significant.
        </p>
      </div>
      <p>The User Agent MUST NOT fire the <code><a>devicechange</a></code> event based on
      changes in the set of available sources from <code><a>getDisplayMedia</a></code>.</p>
    </section>
    <section>
      <h2>
        Security and Permissions
      </h2>
      <p>
        This section is informative; however, it notes some serious risks to platform security if
        the advice it contains are not adhered to.
      </p>
      <p class="issue">
        This is consistent with other documents, but the absence of strong normative language here
        is a little worrying.
      </p>
      <p>
        The risks to user privacy and security posed by capture of displayed content are twofold.
        The immediate and obvious risk is that users inadvertently share content that they did not
        wish to share, or might not have realized would be shared.
      </p>
      <p>
        Display capture presents a less obvious risk to the cross site request forgery protections
        offered by the browser sandbox. Display and capture of information that is also under the
        control of an application, even indirectly, can allow that application to access
        information that would otherwise by inaccessible to it directly. For example, the canvas
        API does not permit sampling of a canvas, or conversion to an accessible form if it is not
        origin-clean [[2DCONTEXT]].
      </p>
      <p>
        This issue is discussed in further detail in [[!RTCWEB-SECURITY-ARCH]] and
        [[!RTCWEB-SECURITY]].
      </p>
      <p>
        Display capture that includes browser windows, particularly those that are under any form
        of control by the application, risks violation of these basic security protections. This
        risk is not entirely contained to browser windows, since control channels between browser
        applications and other applications, depending on the operating system. The key
        consideration is whether the captured <a>display surface</a> could be somehow induced to
        present information that would otherwise be secret from the application that is receiving
        the resulting media.
      </p>
      <p>
        When rendering applications fullscreen, an user agent must be 
        prepared to handle certain transient behaviors where the action to capture an 
        application/window in fullscreen may be reverted, say due to user canceling the 
        action immediately. In these scenarios, the user agent MUST ensure that the 
        captured display surface is restored to the application/window  
        originating the action.
      </p>
      <section>
        <h2>
          Capturing Logical or Visible Display Surfaces
        </h2>
        <p>
          Capture of <a>logical display surfaces</a> causes there to be a potential for content to
          be shared that a user is not made aware of. A <a>logical display surface</a> might render
          information that a user did not intend to expose. This can be more easily recognized if
          this information is visible. Such means are likely ineffectual against a machine, but a
          human recipient is less able to process content that appears only briefly.
        </p>
        <p>
          Information that is not currently rendered to the screen SHOULD be obscured in captures
          unless the application has been specifically authorized to access that content (this
          might require <a>elevated permissions</a>).
        </p>
        <p>
          How obscured areas of the <a>logical display surface</a> are captured to produce a
          <a>visible display surface</a> capture MAY vary. Some applications, like presentation
          software, benefit from having obscured portions of the screen render the image that
          appeared prior to being obscured. Freezing images can cause visual artifacts for changing
          content, or hide the fact that content is being obscured. Note that frozen portions of a
          capture can be incorrectly perceived as a bug. Alternatively, obscured areas might be
          replaced with content that marks them as being obscured, such as a grey color or
          hatching.
        </p>
        <p>
          Some systems MAY only capture the <a>logical display surface</a>. Devices with small
          screens, for instance, do not typically have the concept of a <a>window</a>, and render
          applications in full screen modes only. These systems might provide a capture of an
          application that is not currently visible, which could be unusable without capturing the
          <a>logical display surface</a>.
        </p>
        <p>
          An important consideration when capturing a <a>window</a> or other <a>display surface</a>
          that is partially transparent is that content from the background might be shared. A
          <a>user agent</a> MUST NOT capture content from the background of a captured <a>display
          surface</a>.
        </p>
      </section>
      <section>
        <h2>
          Authorizing Display Capture
        </h2>
        <p>
          This document provides recommends that implementations provide additional limitations on
          the mechanisms used to affirm user consent. These limitations are designed to mitigate
          the security and privacy risks that the API poses.
        </p>
        <p>
          Two forms of consent interaction are described: <a>active user consent</a> and a range of
          <a>elevated permissions</a>. These are non-normative recommendations only.
        </p>
        <section>
          <h2>
            Active User Consent
          </h2>
          <p>
            <dfn>Active user consent</dfn> is sufficient where there is little or no risk of an
            application gaining information that the user did not intend to share. These cases can
            be identified by those where the application that requests capture has no control over
            what is rendered to the captured <a>display surface</a>.
          </p>
          <p>
            To prevent applications from limiting the available choices presented to a user with
            the goal of promoting a particular choice, the <code><a>getDisplayMedia</a></code> API
            does not permit the use of constraints to narrow the set of options presented.
          </p>
        </section>
        <section>
          <h2>
            Elevated Permissions
          </h2>
          <p>
            It is strongly advised that <dfn>elevated permissions</dfn> be required to access any
            <a>display surface</a> that might be used to circumvent cross-origin protections for
            content. The key goal of this consent process is not just to demonstrate that a user
            intends to share content, but to also to determine that the user exhibits an elevated
            level of trust in the application that is being granted access.
          </p>
          <p>
            Several different controls might be provided to grant <a>elevated permissions</a>. This
            section describes several different capabilities that could be independently granted. A
            <a>user agent</a> might opt to prohibit access to any capability that requires
            <a>elevated permissions</a>.
          </p>
          <p>
            If access to these surfaces is supported, it is strongly advised that any mechanism to
            acquire <a>elevated permissions</a> not rely solely on simple prompts for user consent.
            Any action needs to ensure that a decision to authorize an application with elevated
            privileges is deliberate. For instance, a <a>user agent</a> might require a process
            equivalent to software installation to signify that user consent for <a>elevated
            permissions</a> is granted.
          </p>
          <p>
            An <a>elevated permissions</a> experience could allow the <a>user agent</a> to
            communicate the risks associated with enabling this feature, or at least to convey the
            need for augmented trust in the application.
          </p>
          <p>
            Note that <a>elevated permissions</a> are not a substitute for <a>active user
            consent</a>. It is advised that <a>user agents</a> still present users with the ability
            to select what is shared, even for applications that have <a>elevated permissions</a>.
          </p>
        </section>
        <section>
          <h2>
            Capabilities Depending on Elevated Permissions
          </h2>
          <p>
            <a>Elevated permissions</a> are recommended as a prerequisite for access to capture of
            <a>monitor</a> or <a>browser</a> <a>display surfaces</a>. Note that capture of a
            complete <a>monitor</a> is included because this could include a window from the
            <a>user agent</a>.
          </p>
          <p>
            Similarly, <a>elevated permissions</a> are a recommended prerequisite for access to
            <a>logical display surfaces</a>, where that would not ordinarily be provided.
          </p>
          <p>
            A <a>user agent</a> SHOULD persist any <a>elevated permissions</a> that are granted to
            an origin. An <a>elevated permissions</a> process in part relies on its novelty to
            ensure that it correctly captures user intent.
          </p>
        </section>
      </section>
      <section>
        <h2>
          Feedback and Interface During Capture
        </h2>
        <p>
          Implementations are advised to provide user feedback and control mechanisms similar to
          those offered users when sharing a camera or microphone, as recommended in
          [[GETUSERMEDIA]].
        </p>
        <p>
          It is important that a user be aware that content is being shared when content is
          actively being captured. <a>User agents</a> are advised to display a prominent indicator
          while content is being captured. In addition to an indicator, a <a>user agent</a> is
          advised to provide a means to learn precisely what is being shared; while this capability
          is trivially provided by an application by rendering the captured content, this
          information allows a user to accurately assess what is being shared.
        </p>
        <p>
          In addition to feedback mechanisms, a means to for the user to stop any active capture is
          advisable.
        </p>
      </section>
    </section>
  </body>
</html>
