<!DOCTYPE html>
<html lang="en-us">
  <head>
    <link href="screenshare.css" rel="stylesheet" type="text/css">
    <title>
      Screen Capture
    </title>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <script class="remove" src="screenshare.js" type="text/javascript"></script>
  <script class="remove" src="https://www.w3.org/Tools/respec/respec-w3c"></script>
  </head>
  <body>
    <section id="abstract">
      <p>
        This document defines how a user's display, or parts thereof, can be used as the source of
        a media stream using {{MediaDevices/getDisplayMedia}}, an extension to the Media Capture API
        [[GETUSERMEDIA]].
      </p>
    </section>
    <section id="sotd">
      <p>
        This document is not complete. It is subject to major changes and, while early
        experimentations are encouraged, it is therefore not intended for implementation.
      </p>
    </section>
    <section class="informative" id="intro">
      <h2>
        Introduction
      </h2>
      <p>
        This document describes an extension to the Media Capture API [[GETUSERMEDIA]] that enables
        the acquisition of a user's display, or part thereof, in the form of a video track. In some
        cases system, application or window audio is also captured which is presented in the form
        of an audio track. This enables a number of applications, including screen sharing using
        WebRTC [[WEBRTC]].
      </p>
      <p>
        This feature has signficant security implications. Applications that use this API to access
        information that is displayed to users could access confidential information from other
        origins if that information is under the control of the application. This includes content
        that would otherwise be inaccessible due to the protections offered by the user agent
        sandbox.
      </p>
      <p>
        This document concerns itself primarily with the capture of video and audio [[GETUSERMEDIA]],
        but the general mechanisms defined here could be extended to other types of media, of which
        depth [[MEDIACAPTURE-DEPTH]] is currently defined.
      </p>
    </section>
    <section id="conformance">
      <p>
        This specification defines conformance criteria that apply to a single product: the
        <dfn data-lt="user agents">user agent</dfn> that implements the interfaces that it
        contains.
      </p>
      <p>
        Implementations that use ECMAScript [[ECMA-262]] to implement the APIs defined in this
        specification must implement them in a manner consistent with the ECMAScript Bindings
        defined in the Web IDL specification [[!WEBIDL]], as this specification uses that
        specification and terminology.
      </p>
    </section>
    <section>
      <h2>
        Example
      </h2>
      <p>
        The following example demonstrates a request for display capture using the
        <code>navigator.mediaDevices.getDisplayMedia</code> method defined in this document.
      </p>
      <pre class="example highlight">try {
  let mediaStream = await navigator.mediaDevices.getDisplayMedia({video:true});
  videoElement.srcObject = mediaStream;
} catch (e) {
  console.log('Unable to acquire screen capture: ' + e);
}</pre>
    </section>
    <section>
      <h2>
        Terminology
      </h2>
      <p>
        This document uses the definition of {{MediaStream}}, {{MediaStreamTrack}},
        {{MediaStreamConstraints}} and {{ConstrainablePattern}}
        from [[!GETUSERMEDIA]].
      </p>
      <p>
        Screen capture encompasses the capture of several different types of screen-based surfaces.
        Collectively, these are referred to as <dfn data-lt="display surface">display
        surfaces</dfn>, of which this document defines the following types:
      </p>
      <ul>
        <li>A <dfn>monitor</dfn> <a>display surface</a> represents a physical display. Some systems
        have multiple <a>monitor</a>s, which can be identified separately. Multiple <a>monitor</a>s
        might also be aggregated into a single logical <a>monitor</a>. An aggregated <a>display
        surface</a> is captured as a single {{MediaStreamTrack}}.
        </li>
        <li>A <dfn data-lt="windows">window</dfn> <a>display surface</a> is a single contiguous
        surface that is used by a single application.
        </li>
        <li>A single application might have several <a>windows</a> available to it, and those can
        be aggregated into a single <dfn>application</dfn> surface, representing all the windows
        available to that application and therefore presented as a single
        {{MediaStreamTrack}}.
        </li>
        <li>A <dfn>browser</dfn> <a>display surface</a> is the rendered form of a
        [=browsing context=].
        This is not strictly limited to HTML [[HTML]] documents, though the discussion in this
        document will address some specific concerns with the capture of HTML.
        </li>
      </ul>
      <p>
        This document draws a distinction between two variants of each type of display surface:
      </p>
      <ul>
        <li>A <dfn data-lt="logical display surfaces">logical display surface</dfn> is the surface
        that an operating system makes available to an application for the purposes of rendering.
        </li>
        <li>a <dfn>visible display surface</dfn> is the portion of a [=logical display surface=]
        that is rendered to a [=monitor=].
        </li>
      </ul>
      <p>
        Some operating systems permit windows from different applications to occlude other windows,
        in whole or part, so the <a>visible display surface</a> is a strict subset of the
        <a>logical display surface</a>.
      </p>
      <p>
        The <dfn>source pixel ratio</dfn> of a <a>display surface</a> is 1/96th of 1 inch divided
        by its vertical pixel size.
      </p>

      <p>The <dfn>devicechange</dfn> event is defined in [[GETUSERMEDIA]].</p>
    </section>
    <section>
      <h2>
        Capturing Displayed Media
      </h2><!--
      Interesting Links

      https://bugzilla.mozilla.org/show_bug.cgi?id=742832

      http://www.chromium.org/developers/design-documents/extensions/proposed-changes/apis-under-development/webrtc-tab-content-capture

      https://docs.google.com/document/d/1-vFghorm8zDCeyg2Yk6kKFT-16GU1Ow1b1bor_jCqD8/edit
      -->
      <p>
        Capture of displayed media is enabled through the addition of a new
        {{MediaDevices/getDisplayMedia}} method on the {{MediaDevices}}
        interface, that is similar to {{MediaDevices/getUserMedia()}}
        , except that it acquires media from one display device
        chosen by the end-user each time.
      </p>
      <section>
        <h2>
          <dfn>MediaDevices</dfn> Additions
        </h2>
        <pre class="idl"
>partial interface MediaDevices {
  Promise&lt;MediaStream&gt; getDisplayMedia(optional DisplayMediaStreamConstraints constraints = {});
  undefined setCaptureHandleConfig(optional CaptureHandleConfig config = {});
};</pre>
        <dl data-link-for="MediaDevices" data-dfn-for="MediaDevices" class="methods">
          <dt>
            <dfn>getDisplayMedia</dfn>
          </dt>
          <dd>
            <p>Prompts the user for permission to live-capture their display.</p>
            <p>
              The user agent MUST let the end-user choose which display surface to share
              out of all available choices every time, and MUST NOT use
              <var>constraints</var> to limit that choice. Instead,
              <var>constraints</var> MUST be applied to the media chosen by the user,
              only after they have made their selection. This prevents an application
              from influencing the selection of sources, see <a href="#constraints"></a>
              for details.
            </p>
            <p>
              In the case of audio, the user agent MAY present the end-user with audio sources
              to share. Which choices are available to choose from is up to the user agent, and
              the audio source(s) are not necessarily the same as the video source(s). An audio
              source may be a particular <a>application</a>, <a>window</a>, <a>browser</a>, the
              entire system audio or any combination thereof. Unlike
              {{MediaDevices/getUserMedia()}} with regards to audio+video, the user agent is
              allowed not to return audio even if the audio constraint is present. If the user
              agent knows no audio will be shared for the lifetime of the stream it MUST NOT
              include an audio track in the resulting stream. The user agent MAY accept a
              request for audio and video by only returning a video track in the resulting
              stream, or it MAY accept the request by returning both an audio track and a video
              track in the resulting stream. The user agent MUST reject audio-only requests.
            </p>
            <p>
              In addition to drawing from a different set of sources and requiring user selection,
              {{MediaDevices/getDisplayMedia}} also differs from
              {{MediaDevices/getUserMedia()}} in that {{PermissionState/"granted"}} permissions cannot be persisted.
            </p>
            <p>When the {{MediaDevices/getDisplayMedia()}}
            method is called, the User Agent MUST run the following
            steps:</p>
            <ol>
              <li>
                <p>If the [=relevant global object=] of [=this=] does not have
          [=transient activation=], return a promise <a>rejected</a>
                with a {{DOMException}} object whose {{DOMException/name}}
                attribute has the value {{InvalidStateError}}.</p>
              </li>
              <li>
                <p>Let <var>constraints</var> be the method's first
                argument.</p>
              </li>
              <li>
                <p>If <code>constraints.video</code> is <code>false</code>,
                  return a promise [=reject|rejected=] with a newly
                  [=exception/created=] {{TypeError}}.</p>
              </li>
              <li>
                <p>For each [= map/exist | existing =] member
                in <var>constraints</var> whose value, <var>CS</var>, is
                a dictionary, run the following steps:</p>
                <ol>
                  <li>
                    <p>If <var>CS</var> contains a member named <code>advanced</code>,
                    return a promise [=reject|rejected=] with a newly
                    [=exception/created=] {{TypeError}}.</p>
                  </li>
                  <li>
                    <p>If <var>CS</var> contains a member whose name specifies a
                    constrainable property applicable to [=display surface=]s,
                    and whose value in turn is a dictionary containing a member
                    named either <code>min</code> or <code>exact</code>, return
                    a promise [=reject|rejected=] with a newly
                    [=exception/created=] {{TypeError}}.</p>
                  </li>
                  <li>
                    <p>If <var>CS</var> contains a member whose name,
                    <var>failedConstraint</var> specifies a
                    constrainable property, <var>constraint</var>, applicable to
                    [=display surface=]s, and whose value in turn is a
                    dictionary containing a member named <code>max</code>, and
                    that member's value in turn is less than the constrainable
                    property's [=floor value=], then let
                    <var>failedConstraint</var> be the name of the
                    <var>constraint</var>, let <var>message</var> be either
                    <code>undefined</code> or an informative human-readable
                    message, and return a promise [=reject|rejected=] with a new
                    <code>OverconstrainedError</code> created by calling
                    <code>OverconstrainedError(<var>failedConstraint</var>,
                    <var>message</var>)</code>.
                  </li>
                </ol>
              </li>
              <li>
                <p>Let <var>requestedMediaTypes</var> be the set of media
                types in <var>constraints</var> with either a dictionary
                value or a value of <code>true</code>.</p>
              </li>
              <li>
                <p>If the <a>current settings object</a>'s [=environment settings object/responsible document=] is NOT [=Document/fully active=], return
                  a promise [=reject|rejected=] with a
                  {{DOMException}} object whose
                  {{DOMException/name}} attribute has the value
                  {{InvalidStateError}}.</p>
              </li>
              <li>
                <p>Let <var>p</var> be a new promise.</p>
              </li>
              <li>
                <p>Run the following steps in parallel:</p>
                <ol>
                  <li>
                    <p>For each media type <var>T</var> in
                    <var>requestedMediaTypes</var>,</p>
                    <ol>
                      <li>
                        <p>If no sources of type <var>T</var> are available,
                        <a>reject</a> <var>p</var> with a new
                        {{DOMException}} object whose
                        {{DOMException/name}} attribute has the value
                        {{NotFoundError}}.</p>
                      </li>
                      <li>
                        <p>Read the current [= permission state=] for obtaining
                        sources of type <var>T</var> in the current browsing
                        context. If the permission state is {{PermissionState/"denied"}}, jump to
                        the step labeled <em>PermissionFailure</em> below.</p>
                      </li>
                    </ol>
                  </li>
                  <li>
                    <p>Optionally, e.g., based on a previously-established
                    user preference, for security reasons, or due to platform
                    limitations, jump to the step labeled <em>Permission Failure</em> below.</p>
                  </li>
                  <li>
                    <p>[=Prompt the user to choose=]
                    a display device, with a {{PermissionDescriptor}} named
                    {{PermissionName/"display-capture"}}, resulting in a set of
                    provided media.</p>
                    <p>The provided media MUST include precisely one track of
                    each media type in <var>requestedMediaTypes</var>.
                    The devices chosen MUST be the ones determined by the user.
                    Once selected, the source of a
                    {{MediaStreamTrack}} MUST NOT change.</p>
                    <p>User Agents are encouraged to warn users against sharing
                    <a>browser</a> display devices as well as <a>monitor</a>
                    display devices where browser windows are visible, or
                    otherwise try to discourage their selection on the basis
                    that these represent a significantly higher risk when shared.</p>
                    <p>If the result of the request is {{PermissionState/"granted"}}, then for
                    each device that is sourcing the provided media, using
                    a stable and private id for the device, <var>deviceId</var>,
                    set [[\devicesLiveMap]]<var>[deviceId]</var> to
                    <code>true</code>, if it isn’t already <code>true</code>,
                    and set the
                    [[\devicesAccessibleMap]]<var>[deviceId]</var> to
                    <code>true</code>, if it isn’t already
                    <code>true</code>.</p>
                    <p>The User Agent MUST NOT
                    store a {{PermissionState/"granted"}} permission entry.
                    </p>
                    <p>If the result is {{PermissionState/"denied"}}, jump to the step labeled
                    <em>Permission Failure</em> below. If the user never
                    responds, this algorithm stalls on this step.</p>
                    <p>If the user grants permission but a hardware error
                    such as an OS/program/webpage lock prevents access,
                    <a>reject</a> <var>p</var> with a new
                    {{DOMException}} object whose
                    {{DOMException/name}} attribute has the value
                    {{NotReadableError}} and abort these steps.</p>
                    <p>If the result is {{PermissionState/"granted"}} but device access fails for
                    any reason other than those listed above, <a>reject</a>
                    <var>p</var> with a new {{DOMException}}
                    object whose {{DOMException/name}} attribute has the
                    value {{AbortError}} and abort these steps.</p>
                  </li>
                  <li>
                    <p>Let <var>stream</var> be the
                    {{MediaStream}} object for which the user
                    granted permission.</p>
                  </li>
                  <li>
                    <p>Run the [=ApplyConstraints algorithm=] on all
                    tracks in <var>stream</var> with the appropriate
                    constraints. Should this fail, let <var>failedConstraint</var>
                    be the result of the algorithm that failed, and let
                    <var>message</var> be either <code>undefined</code> or an
                    informative human-readable message, and then <a>reject</a>
                    <var>p</var> with a new <code>OverconstrainedError</code>
                    created by calling
                    <code>OverconstrainedError(<var>failedConstraint</var>,
                    <var>message</var>)</code>.</p>
                  </li>
                  <li>
                    <p><a>Resolve</a> <var>p</var> with <var>stream</var> and
                    abort these steps.</p>
                  </li>
                  <li>
                    <p><em>Permission Failure</em>: [=Reject=]
                    <var>p</var> with a new {{DOMException}}
                    object whose {{DOMException/name}} attribute has the
                    value {{NotAllowedError}}.</p>
                  </li>
                </ol>
              </li>
              <li>
                <p>Return <var>p</var>.</p>
              </li>
            </ol>
          </dd>
        </dl>
        <dl data-link-for="MediaDevices" data-dfn-for="MediaDevices">
          <dt>
            <dfn>setCaptureHandleConfig</dfn>
          </dt>
          <dd>
            <p>
              Allows an application <code>app</code> to signal to the user agent what information
              the user agent may expose to applications that display-capture <code>app</code>.
            </p>
            <p>
              Navigating a document is treated as an implicit call to {{MediaDevices/setCaptureHandleConfig}}
              with the [=empty configuration|Empty CaptureHandleConfig=].
            </p>
          </dd>
        </dl>
      </section>
      <section>
        <h2 id="hidden-display-surfaces">
          Closed and Minimized Display Surfaces
        </h2>
        <p>
          A <a>display surface</a> that is being shared may temporarily or permanently become
          inaccessible to the application because of actions taken by the operating system or user
          agent. What makes a <a>display surface</a> considered inaccesible is outside the scope
          of this specification, but examples MAY include a <a>monitor</a> disconnecting or an
          <a>application</a>, <a>window</a> or <a>browser</a> closing or becoming minimized.
        </p>
        <p>
          When <a>display surface</a> enters an inaccessible state that is not necessarily
          permanent, the user agent MUST queue a task that
          [= set a track's muted state|sets the muted state =]
          of the corresponding media track to <code>true</code>.
        </p>
        <p>
          When <a>display surface</a> exits an inaccessible state and becomes accessible, the
          user agent MUST queue a task that
          [= set a track's muted state|sets the muted state =]
          of the corresponding media track to <code>false</code>.
        </p>
        <p>
          When a <a>display surface</a> enters an inaccessible state that is permanent (such as
          the source application terminating), the user agent MUST queue a task that
          [= track/ended | ends =] the
          corresponding media track.
        </p>
        <p>
          A stream that was just returned by {{MediaDevices/getDisplayMedia}} MAY contain
          tracks that are muted by default. Audio and video tracks belonging to the same stream
          MAY be muted/unmuted independently of one another.
        </p>
      </section>
      <section>
        <h2 id="constraints">
          Unconstrained Display Surface Selection
        </h2>
        <p class="fingerprint">
          Not accepting constraints for source selection means that
          {{MediaDevices/getDisplayMedia}} only provides fingerprinting surface that exposes
          whether audio, video or audio and video display sources are present. <img alt=
          "(This is a fingerprinting vector.)" src="images/fingerprint.png" width="15" height="21">
        </p>
      </section>
      <section>
        <h2 id="constrainable-properties">
          Constrainable Properties for Captured Display Surfaces
        </h2>
        <p>Constraints serve a different purpose in
        {{MediaDevices/getDisplayMedia}} than they do in
        {{MediaDevices/getUserMedia()}}.
        They do not aid discovery, instead they are applied only after user-selection.</p>
        <p>This section define which constraints apply to {{MediaDevices/getDisplayMedia}} tracks;
        constraints defined for
        {{MediaDevices/getUserMedia()}}
        do not apply unless listed here.</p>
        <p>Some of these constraints enable user agent processing like downscaling
        and frame decimation, as well as display-specific features. Others enable
        observation of inherent properties of a user-selected
        <a>display surface</a>, as capabilities and settings.</p>
        <p>The following new and existing {{MediaStreamTrack}}
        <a data-cite="GETUSERMEDIA#constrainable-properties">
        Constrainable Properties</a> are defined to apply to the user-selected
        video <a>display surface</a>, with the following behavior:</p>
        <table class="simple">
          <thead>
            <tr>
              <th>Property Name</th>
              <th>Type</th>
              <th>Behavior</th>
            </tr>
          </thead>
          <tbody>
            <tr id="def-constraint-width">
              <td><dfn>width</dfn></td>
              <td>{{ConstrainULong}}</td>
              <td>The width or width range, in pixels. As a capability, max MUST
              reflect the <a>display surface</a>'s width, and min MUST reflect
              the width of the smallest aspect-preserving representation
              available through downscaling by the user agent.</td>
            </tr>
            <tr id="def-constraint-height">
              <td><dfn>height</dfn></td>
              <td>{{ConstrainULong}}</td>
              <td>The height or height range, in pixels. As a capability, max
              MUST reflect the <a>display surface</a>'s height, and min MUST
              reflect the height of the smallest aspect-preserving
              representation available through downscaling by the user agent.
              </td>
            </tr>
            <tr id="def-constraint-frameRate">
              <td><dfn>frameRate</dfn></td>
              <td>{{ConstrainDouble}}</td>
              <td>The frame rate (frames per second) or frame rate range. As a
              capability, max MUST reflect the <a>display surface</a>'s frame
              rate, and min MUST reflect the lowest frame rate available through
              frame decimation by the user agent.</td>
            </tr>
            <tr id="def-constraint-aspect">
              <td><dfn>aspectRatio</dfn></td>
              <td>{{ConstrainDouble}}</td>
              <td>The exact aspect ratio (width in pixels divided by height in
              pixels, represented as a double rounded to the tenth decimal
              place) or aspect ratio range. As a setting, represents
              <code>width / height</code>. As a capability, min
              and max both MUST be the current setting value, rendering this
              property immutable from the application viewpoint.</td>
            </tr>
            <tr id="def-constraint-resizeMode">
              <td><dfn>resizeMode</dfn></td>
              <td>{{ConstrainDOMString}}</td>
              <td>
                This string (or each string, when a list) should be one of the members of
                {{VideoResizeModeEnum}}.
                As a setting, {{VideoResizeModeEnum/"none"}} means the {{MediaStreamTrack}}
                contains all bits needed to render the display in full detail,
                which if the <code><a>source pixel ratio</a> &gt; 1</code>, means
                <code>width</code> and <code>height</code> will be larger
                than the display's appearance from an end-user viewpoint would
                suggest, whereas {{VideoResizeModeEnum/"crop-and-scale"}} means the
                {{MediaStreamTrack}} contains an
                aspect-preserved representation of the <a>display surface</a>
                that has been downscaled by the user agent, but not cropped. As
                a capability, the values {{VideoResizeModeEnum/"none"}} and
                {{VideoResizeModeEnum/"crop-and-scale"}} both MUST be present.
              </td>
            </tr>
            <tr id="def-constraint-displaySurface">
              <td><dfn>displaySurface</dfn></td>
              <td>{{ConstrainDOMString}}</td>
              <td>
                This string (or each string, when a list) should be one of the
                members of {{DisplayCaptureSurfaceType}}. As a
                setting, indicates the type of [=display surface=] that
                is being captured. As a capability, the setting value MUST be
                the lone value present, rendering this property immutable from
                the application viewpoint.
              </td>
            </tr>
            <tr id="def-constraint-logicalSurface">
              <td><dfn>logicalSurface</dfn></td>
              <td>{{ConstrainBoolean}}</td>
              <td>
                As a setting, a value of <code>true</code> indicates capture of
                a [=logical display surface=], whereas a value of
                <code>false</code> indicates a capture of a
                [=visible display surface=]. As a capability, this same
                value MUST be the lone value present, rendering this
                property immutable from the application viewpoint.
              </td>
            </tr>
            <tr id="def-constraint-cursor">
              <td><dfn>cursor</dfn></td>
              <td>{{ConstrainDOMString}}</td>
              <td>
                This string (or each string, when a list) should be one of the
                members of {{CursorCaptureConstraint}}. As a
                setting, indicates if and when the cursor is included in the
                captured [=display surface=].  As a capability, the user
                agent MUST include only the set of values from
                {{CursorCaptureConstraint}} it is capable of
                supporting for this [=display surface=].
              </td>
            </tr>
          </tbody>
        </table>
        <p>The following new and existing {{MediaStreamTrack}}
        <a data-cite="GETUSERMEDIA#constrainable-properties">
        Constrainable Properties</a> are defined to apply to the user-selected
        audio sources, with the following behavior:</p>
        <table class="simple">
          <thead>
            <tr>
              <th>Property Name</th>
              <th>Type</th>
              <th>Behavior</th>
            </tr>
          </thead>
          <tbody>
            <tr id="def-constraint-restrictOwnAudio">
              <td><dfn>restrictOwnAudio</dfn></td>
              <td>{{ConstrainBoolean}}</td>
              <td>
                <p>As a setting, this value indicates whether or not the user
                agent is applying <a>own audio restriction</a> to the
                source.</p>
                <p>As a constraint, this property can be constrained resulting
                in a source with <a>own audio restriction</a> enabled or
                disabled.</p>
                <p>When <dfn>own audio restriction</dfn> is applied, the user
                agent MUST attempt to remove any audio from the audio being
                captured that was produced by the document that performed
                {{MediaDevices/getDisplayMedia}}. If the user agent is not able to
                remove the audio through processing it SHOULD remove the audio
                by excluding the document's audio from being captured. If
                this results in no audio being captured, the user agent MUST
                keep the track muted until it is able to capture audio
                again.</p>
              </td>
            </tr>
          </tbody>
        </table>  
        <p>When inherent properties of the underlying source of a user-selected
        <a>display surface</a> change, for example in response to the end-user
        resizing a captured window, and these changes render the capabilities
        and/or settings of one or more constrainable properties outdated, the
        user agent MUST queue a task to run the following step:</p>
        <ol>
          <li>
            <p>Update all affected constrainable properties at the same time.</p>
            <p>If this causes an "overconstrained" situation, then the user agent
            MUST ignore the culprit constraints for as long as they
            overconstrain. The user agent MUST NOT mute the track, and
            the user agent MUST NOT fire the
            <a href="https://www.w3.org/TR/mediacapture-streams#event-mediastreamtrack-overconstrained">overconstrained</a>
            event.</p>
          </li>
        </ol>
        <div class="note">
          <p>While min and exact constraints produce TypeError on
          getDisplayMedia(), this specification does not alter the
          track.applyConstraints() method. Therefore, they may instead produce
          OverconstrainedError or succeed depending on values, and therefore
          potentially be present to cause this "overconstrained" situation.
          The max constraint may also cause this, e.g. with aspectRatio. This
          spec considers these to be edge cases that aren't useful.</p>
        </div>
        <section>
          <h2>
            Downscaling and Frame Decimation
          </h2>
          <p>For the purposes of the
          [=SelectSettings=]
          algorithm, the user agent SHOULD consider all possible combinations of
          downscaled dimensions that preserve the aspect ratio of the original
          <a>display surface</a> (to the nearest pixel), and frame rates
          available through frame decimation, as available
          [= settings dictionaries =].
          </p>
          <p>The downscaling and decimation effects of constraints is then
          effectively governed by the
          [= fitness distance =] algorithm.</p>
          <p>The intent is for the user agent to produce output that is close to
          the ideal <code>width</code>, ideal <code>height</code>, and/or
          ideal <code>frameRate</code> when these are specified, while at all
          times preserving the aspect ratio of the original <a>display surface</a>.
          </p>
          <p>The user agent SHOULD downscale by the <a>source pixel ratio</a> by
          default, unless otherwise directed by applied constraints.
          </p>
          <p>The user agent MUST NOT crop the captured output.</p>
          <p>The user agent MUST NOT upscale the captured output, or create
          additional frames, except as needed to preserve high resolutions and
          frame rates in an aggregated <a>display surface</a>.</p>
          <div class="note">
            <p>The max constraint type lets a web application provide a maximum
            envelope for constrainable properties like width and height. This is
            helpful to limit extreme aspect ratios, should the end-user resize a
            <a>window</a> or <a>browser</a> surface to such an extreme while
            it is being captured.</p>
          </div>
          <p>For each constrainable property of positive numeric type in this
          specification, the user agent MUST establish a <dfn>floor value</dfn>,
          representing the smallest allowable value supported by the user agent
          regardless of source. This value MUST be constant and MUST be greater
          than <code>0</code>. The user agent is encouraged to support all
          values above the <a>floor value</a> regardless of source.</p>
          <div class="note">
            <p>The purpose of the <a>floor value</a> is to help user agents
            avoid failing {{MediaDevices/getDisplayMedia()}} with
            <code>OverconstrainedError</code> after the user has already been
            prompted, and avoid leaking information about the user's system.
            </p>
          </div>
        </section>
        <section>
          <h2>DisplayMediaStreamConstraints</h2>
          <p>The <dfn>DisplayMediaStreamConstraints</dfn> dictionary is used to
          instruct the User Agent what sort of {{MediaStreamTrack}}s may be
          included in the {{MediaStream}} returned by
          {{MediaDevices/getDisplayMedia}}.</p>
          <div>
            <pre class="idl">
dictionary DisplayMediaStreamConstraints {
  (boolean or MediaTrackConstraints) video = true;
  (boolean or MediaTrackConstraints) audio = false;
};</pre>
            <section>
              <h2>Dictionary <a class="idlType">DisplayMediaStreamConstraints</a>
                Members</h2>
              <dl data-link-for="DisplayMediaStreamConstraints" data-dfn-for=
                "DisplayMediaStreamConstraints" class="dictionary-members">
                <dt><dfn><code>video</code></dfn> of type <code>(boolean or {{MediaTrackConstraints}})</code>,
                defaulting to <code>true</code></dt>
                <dd>
                  <p>If <code>true</code>, it requests that the returned
                  {{MediaStream}} contain a video track. If a <code>Constraints</code>
                  structure is provided, it further specifies desired processing
                  options to be applied to the video track rendition of the
                  display surface chosen by the user. If <code>false</code>, the
                  request MUST be [=rejected=] with a {{TypeError}}.</p>
                </dd>
                <dt><dfn><code>audio</code></dfn> of type <code>(boolean or {{MediaTrackConstraints}})</code>,
                defaulting to <code>false</code></dt>
                <dd>
                  <p>If <code>true</code>, it signals an interest that the
                  returned {{MediaStream}} contain an audio track, if
                  supported and audio is available for display surface chosen by
                  the user. If a <code>Constraints</code> structure is provided, it
                  further specifies desired processing options to be applied to
                  the audio track. If <code>false</code>, the {{MediaStream}}
                  MUST NOT contain an audio track.</p>
                </dd>
              </dl>
            </section>
          </div>
        </section>
        <section>
          <h2>
            Extensions to {{MediaTrackSupportedConstraints}}
          </h2>
          <p>
            {{MediaTrackSupportedConstraints}}
             is extended here with the list of constraints that a User
            Agent recognizes.
          </p>
          <pre class="idl"
>partial dictionary MediaTrackSupportedConstraints {
  boolean displaySurface = true;
  boolean logicalSurface = true;
  boolean cursor = true;
  boolean restrictOwnAudio = true;
};</pre>
          <dl  data-dfn-for="MediaTrackSupportedConstraints"
          class="dictionary-members">
            <dt>
              <dfn>displaySurface</dfn> of type {{boolean}}, defaulting to <code>true</code>
            </dt>
            <dd>
              <p>
                Whether {{displaySurface}} constraint is recognized.
              </p>
            </dd>
            <dt>
              <dfn><code>logicalSurface</code></dfn> of type {{boolean}}, defaulting to <code>true</code>
            </dt>
            <dd>
              <p>
                Whether {{logicalSurface}} constraint is recognized.
              </p>
            </dd>
            <dt>
              <dfn>cursor</dfn> of type {{boolean}}, defaulting to <code>true</code>
            </dt>
            <dd>
              <p>
                Whether {{cursor}} constraint is recognized.
              </p>
            </dd>
            <dt>
              <dfn>restrictOwnAudio</dfn> of type {{boolean}}, defaulting to <code>true</code>
            </dt>
            <dd>
              <p>
                Whether {{restrictOwnAudio}} constraint is
                recognized.
              </p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            Extensions to {{MediaTrackConstraintSet}}
          </h2>
          <p>
            {{MediaTrackConstraintSet}} is used for reading the current status of constraints.
          </p>
          <pre class="idl" 
>partial dictionary MediaTrackConstraintSet {
  ConstrainDOMString displaySurface;
  ConstrainBoolean logicalSurface;
  ConstrainDOMString cursor;
  ConstrainBoolean restrictOwnAudio;
};</pre>
          <dl data-dfn-for="MediaTrackConstraintSet" class=
          "dictionary-members">
            <dt>
              <dfn><code>displaySurface</code></dfn> of type {{ConstrainDOMString}}
            </dt>
            <dd>
              <p>
                The type of [=display surface=] that is being captured. This assumes values from
                the {{DisplayCaptureSurfaceType}} enumeration.
              </p>
            </dd>
            <dt>
              <dfn>logicalSurface</dfn> of type {{ConstrainBoolean}}
            </dt>
            <dd>
              <p>
                A value of <code>true</code> indicates capture of a [=logical display surface=];
                a value of <code>false</code> indicates a capture capture of a [=visible display
                surface=].
              </p>
            </dd>
            <dt>
               <dfn>cursor</dfn> of type {{ConstrainDOMString}}
            </dt>
            <dd>
              <p>
                Assumes values from the {{CursorCaptureConstraint}} enumeration that
                determines if and when the cursor is included in the captured display surface.
              </p>
            </dd>
            <dt>
              <dfn>restrictOwnAudio</dfn> of type {{ConstrainBoolean}}
            </dt>
            <dd>
              <p>
                This constraint is only applicable to audio tracks. See
                {{restrictOwnAudio}}.
              </p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            Extensions to {{MediaTrackSettings}}
          </h2>
          <p>
            When the {{MediaStreamTrack/getSettings()}}
            method is invoked on a video stream track, the user agent must return the extended
            {{MediaTrackSettings}}
            dictionary, representing the current status of the underlying user agent.
          </p>
          <pre class="idl"
>partial dictionary MediaTrackSettings {
  DOMString displaySurface;
  boolean logicalSurface;
  DOMString cursor;
  CaptureHandle captureHandle;
};</pre>
          <dl data-link-for="MediaTrackSettings" data-dfn-for="MediaTrackSettings" class=
          "dictionary-members">
            <dt>
              <dfn>displaySurface</dfn> of type {{DOMString}}
            </dt>
            <dd>
              <p>
                The type of [=display surface=] that is being captured. This assumes values from
                the {{DisplayCaptureSurfaceType}} enumeration.
              </p>
            </dd>
            <dt>
              <dfn>logicalSurface</dfn> of type {{boolean}}
            </dt>
            <dd>
              <p>
                A value of <code>true</code> indicates capture of a <a>logical display surface</a>;
                a value of <code>false</code> indicates a capture capture of a <a>visible display
                surface</a>.
              </p>
            </dd>
            <dt>
               <dfn>cursor</dfn> of type {{DOMString}}
            </dt>
            <dd>
              <p>
                Assumes values from the {{CursorCaptureConstraint}} enumeration that
                determines if and when the cursor is included in the captured display surface.
              </p>
            </dd>
            <dt>
               <dfn>captureHandle</dfn> of type {{CaptureHandle}}
            </dt>
            <dd>
              <p>
                The user agent SHOULD expose if and only if the track's underlying source is
                of a type that could have set a {{CaptureHandle}}.
              </p>
              <p>
                <var>captureHandle</var> exposes to a capturing application information set
                by the captured application. The captured application does so either explicitly
                or implicitly.
              </p>
              <ul>
                <li>
                  {{CaptureHandle}} can be set explicitly through {{MediaDevices/setCaptureHandleConfig}}.
                </li>
                <li>
                  Not calling {{MediaDevices/setCaptureHandleConfig}} is an impilict call with the
                  [=Empty CaptureHandleConfig|empty CaptureHandleConfig=].
                </li>
              </ul>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Extensions to {{MediaStreamTrack}}</h2>
          <p>
            When the user agent produces a {{MediaStreamTrack}}, if the track's underlying
            source can set a {{CaptureHandle}}, then the user agent should produce
            an extended {{MediaStreamTrack}} which exposes the following additional attributes.
          </p>
          <pre class="idl">
            partial interface MediaStreamTrack {
              attribute EventHandler oncapturehandleupdate;
            };
          </pre>
          <dl data-link-for="MediaStreamTrack" data-dfn-for="MediaStreamTrack" class="members">
            <dt>
              <dfn>oncapturehandleupdate</dfn> of type {{EventHandler}}
            </dt>
            <dd>
              <p>
                The event type of this event handler is {{capturehandleupdate}}.
              </p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            <dfn>DisplayCaptureSurfaceType</dfn>
          </h2>
          <p>
            The {{DisplayCaptureSurfaceType}} enumeration describes the different
            types of display surface.
          </p>
          <pre class="idl"
>enum DisplayCaptureSurfaceType {
  "monitor",
  "window",
  "application",
  "browser"
};</pre>
          <table  data-dfn-for="DisplayCaptureSurfaceType"
          class="simple">
            <tbody>
              <tr>
                <th colspan="2">
                  Enumeration description
                </th>
              </tr>
              <tr>
                <td>
                  <dfn id="idl-def-DisplayCaptureSurfaceType.monitor">monitor</dfn>
                </td>
                <td>
                  a [=monitor=] [=display surface=], physical display, or collection of
                  physical displays
                </td>
              </tr>
              <tr>
                <td>
                  <dfn id="idl-def-DisplayCaptureSurfaceType.window">window</dfn>
                </td>
                <td>
                  a [= window =] [=display surface=], or single application window
                </td>
              </tr>
              <tr>
                <td>
                  <dfn id=
                  "idl-def-DisplayCaptureSurfaceType.application">application</dfn>
                </td>
                <td>
                  an [= application=] [=display surface=], or entire collection of windows for
                  an application
                </td>
              </tr>
              <tr>
                <td>
                  <dfn id="idl-def-DisplayCaptureSurfaceType.browser">browser</dfn>
                </td>
                <td>
                  a [=browser=] [=display surface=], or single browser window
                </td>
              </tr>
            </tbody>
          </table>
        </section>
        <section>
          <h2>
            <dfn>CursorCaptureConstraint</dfn>
          </h2>
          <p>
            The {{CursorCaptureConstraint}} enumerates the conditions
            under which the cursor is captured.
          </p>
          <pre class="idl"
>enum CursorCaptureConstraint {
  "never",
  "always",
  "motion"
};</pre>
          <table  data-dfn-for="CursorCaptureConstraint"
          class="simple">
            <tbody>
              <tr>
                <th colspan="2">
                  Enumeration description
                </th>
              </tr>
              <tr>
                <td>
                  <dfn id="idl-def-CursorCaptureConstraint.never">never</dfn>
                </td>
                <td>
                  a {{CursorCaptureConstraint/"never"}} cursor capture constraint omits the cursor from the captured display surface.
                </td>
              </tr>
              <tr>
                <td>
                  <dfn id="idl-def-CursorCaptureConstraint.always">always</dfn>
                </td>
                <td>
                  a {{CursorCaptureConstraint/"always"}} cursor capture constraint includes the cursor in the captured display surface.
                </td>
              </tr>
              <tr>
                <td>
                  <dfn id=
                  "idl-def-CursorCaptureConstraint.motion">motion</dfn>
                </td>
                <td>
                  a {{CursorCaptureConstraint/"motion"}} cursor capture constraint includes the cursor in the captured display
                  surface when the cursor/pointer is moved. The captured cursor is removed when there
                  is no further movement of the pointer/cursor for certain period of time, as determined
                  by the <a>user agent</a>.
                </td>
              </tr>
            </tbody>
          </table>
        </section>
        <section>
          <h2><dfn>CaptureHandleConfig</dfn></h2>
          <p>
            Allows an application <code>app</code> to expose information to applications that display-capture <code>app</code>.
          </p>
          <pre class="idl">
            dictionary CaptureHandleConfig {
              boolean exposeOrigin = false;
              DOMString handle = "";
            };</pre>
          <dl data-dfn-for="CaptureHandleConfig" class="dictionary-members">
            <dt>
              <dfn>exposeOrigin</dfn> of type {{boolean}} defaulting to <code>false</code>
            </dt>
            <dd>
              <p>
                Whether the application is opting into exposing its origin to capturing applications.
                If true, the origin is exposed via {{CaptureHandle}}.{{CaptureHandle/origin}}.
              </p>
            </dd>
            <dt>
              <dfn>handle</dfn> of type {{DOMString}} defaulting to <code>""</code>
            </dt>
            <dd>
              <p>
                A self-declared handle the application exposes to capturing applications
                via {{CaptureHandle}}.{{CaptureHandle/handle}}.
                For example, an ID could be exposed that's meaningful to collaborating
                applications - an encyclopedia could expose the article number, a productivity
                suite could expose a session ID that allows communication with it over some
                external API, etc.
              </p>
            </dd>
          </dl>
          <section>
            <h3><dfn>Empty CaptureHandleConfig</dfn></h3>
            <p>
              To clarify, when discussing the [=empty CaptureHandleConfig=], we mean the
              one which has all values set to their defaults, whether implicitly or explicitly.
            </p>
          </section>
        </section>
        <section>
          <h2>
            <dfn>CaptureHandle</dfn>
          </h2>
          <p>
            Information exposed by an application <code>app</code> to any application that might
            display-capture <code>app</code>.
          </p>
          <pre class="idl">
            dictionary CaptureHandle {
              DOMString origin;
              DOMString handle;
            };
          </pre>
          <dl data-dfn-for="CaptureHandle" class="dictionary-members">
            <dt>
              <dfn>origin</dfn> of type {{DOMString}}
            </dt>
            <dd>
              <p>
                If the captured application opted-in to exposing its origin (through
                {{CaptureHandleConfig}}.{{CaptureHandleConfig/exposeOrigin}}),
                then <var>origin</var> is set to the origin of the captured application.
                Otherwise, <var>origin</var> is set to the empty string.
              </p>
            </dd>
            <dt>
              <dfn>handle</dfn> of type {{DOMString}}
            </dt>
            <dd>
              <p>
                If the captured application set a value to {{CaptureHandleConfig/handle}}, then this
                value is reflected here. Otherwise, the empty string.
              </p>
            </dd>
          </dl>
        </section>
        <section>
          <h2><dfn>CaptureHandleUpdateEvent</dfn></h2>
          <p>
            The <dfn>capturehandleupdate</dfn> event uses the {{CaptureHandleUpdateEvent}} interface.
            It is fired whenever the {{CaptureHandle}} of the captured application is updated.
          </p>
          <section>
            <h3>Event Firing</h3>
            <p>
              This event fires in a capturing application whenever an update occurs
              of the {{CaptureHandle}} associated with the captured {{MediaStreamTrack}}.
            </p>
            <p>
              This typically happens when:
            </p>
            <ul>
              <li>
                The top-level document of a captured <a>browser</a> <a>display surface</a>
                calls {{MediaDevices/setCaptureHandleConfig}}.
              </li>
              <li>
                The top-level document of a captured <a>browser</a> <a>display surface</a>
                is navigated. (Note that this includes navigation between two sites that
                do not set a {{CaptureHandleConfig}}, in which case the {{CaptureHandle}}
                is considered "updated" although it did not "change."
              </li>
              </ul>
          </section>
          <section>
            <h3>Event Type Definition</h3>
            <pre class="idl">
              [Exposed=Window]
              interface CaptureHandleUpdateEvent : Event {
                constructor(CaptureHandleUpdateEventInit init);
                [SameObject] CaptureHandle getCaptureHandle();
              };            
            </pre>
            <dl data-link-for="CaptureHandleUpdateEvent" data-dfn-for="CaptureHandleUpdateEvent" class="constructors">
              <dt><dfn>constructor()</dfn></dt>
              <dd>
                <p>
                  Constructs a new {{CaptureHandleUpdateEvent}} based on <var>init</var>.
                </p>
              </dd>
            </dl>
            <dl data-link-for="CaptureHandleUpdateEvent" data-dfn-for="CaptureHandleUpdateEvent" class="methods">
              <dt><dfn>getCaptureHandle()</dfn></dt>
              <dd>
                <p>
                  Getter for the {{CaptureHandle}} of the associated track at the time when the event was fired.
                </p>
              </dd>
            </dl>
          </section>
          <section>
            <h3><dfn>CaptureHandleUpdateEventInit</dfn></h3>
            <pre class="idl">
              dictionary CaptureHandleUpdateEventInit {
                required DOMString origin;
                required DOMString handle;
              };
            </pre>
          </section>
        </section>
      </section>
      <section>
        <h2 id="deviceId">
          Device Identifiers
        </h2>
        <p>
          Each potential source of capture is treated by this API as a discrete media source.
          However, display capture sources MUST NOT be enumerated by {{MediaDevices/enumerateDevices()}},
          since this would reveal too much information about the host
          system.
        </p>
        <p>
          Display capture sources therefore cannot be selected with the {{MediaTrackSupportedConstraints/deviceId}}
          constraint, since their {{MediaDeviceInfo/deviceId}}s are not exposed.
        </p>
        <div class="note">
          <p>
          This is not to be confused with the stable and private id of the same
          name used in algorithms to implement privacy indicators.
          </p>
        </div>
      </section>
    </section>
    <section>
      <h1 id=feature-policy-integration>Permissions Policy Integration</h1>
      <p>This specification defines a [=policy-controlled feature=]
      identified by the string
      <code><dfn data-lt="display-capture-feature">"display-capture"</dfn></code>.
      Its [=default allowlist=] is <code>"self"</code>.
      <div class="note">
        <p>A [=document=]'s
        [=Document/permissions policy=]
        determines whether any content in that document is allowed to use
        {{MediaDevices/getDisplayMedia}}. If disabled in any document, no content in
        the document will be
        [=allowed to use=]
        {{MediaDevices/getDisplayMedia}}. This is enforced by the
        [=prompt the user to choose=] algorithm.
        </p>
      </div>
    </section>
    <section>
      <h1>Privacy Indicator Requirements</h1>
      <p>This specification extends the <a data-cite="GETUSERMEDIA#privacy-indicator-requirements">
        Privacy Indicator Requirements</a> of
      {{MediaDevices/getUserMedia()}} to include {{MediaDevices/getDisplayMedia}}.</p>
      <p>References in this specification to [[\devicesLiveMap]],
      [[\devicesAccessibleMap]], and [[\kindsAccessibleMap]] refer to the
      definitions already created to support Privacy Indicator Requirements for
      {{MediaDevices/getUserMedia()}}.</p>
      <p>For each <var>kind</var> of device that
      {{MediaDevices/getDisplayMedia}} exposes, using a stable and private id
      for the device, <var>deviceId</var>, set <var>kind</var>
      to <code>"Display"</code> + <var>kind</var>, and do the following:
      <ul>
        <li>Define <var>any&lt;kind&gt;Accessible</var> (e.g.
          <var>anyDisplayVideoAccessible</var>) as the
          logical OR of the [[\kindsAccessibleMap]]<var>[kind]</var> value and all
          the [[\devicesAccessibleMap]]<var>[deviceId]</var> values for devices of
          that kind, and initialize all values to <code>false</code>.
        </li>
        <li>Define <var>any&lt;kind&gt;Accessible</var> (e.g.
          <var>anyDisplayVideoAccessible</var>) as the
          logical OR of the [[\kindsAccessibleMap]]<var>[kind]</var> value and all
          the [[\devicesAccessibleMap]]<var>[deviceId]</var> values for devices of
          that kind, and initialize all values to <code>false</code>.
        </li>
        <li>Define any<var>&lt;kind&gt;Live</var> (e.g.
          <var>anyDisplayVideoLive</var>) to be the logical OR of all the
          [[\devicesLiveMap]]<var>[deviceId]</var> values for devices of that
          kind.
        </li>
      </ul>
      <p>Then, given the new definitions above, the requirements on the User
      Agent are those specified in <a data-cite="GETUSERMEDIA#privacy-indicator-requirements">
        Privacy Indicator Requirements</a> of
      {{MediaDevices/getUserMedia()}}.</p>
      <div class="note">
        <p>
        Even though there's a single permission descriptor for {{MediaDevices/getDisplayMedia}},
        the above definitions distinguish by kind to enable user agents
        to implement privacy indicators that show the end-user the specific kinds
        of display sources that are being shared at any point.
        </p>
      </div>
      <div class="note">
        <p>
        Since this specification forbids user agents from persisting {{PermissionState/"granted"}}
        permissions, only the "Live" indicators are significant.
        </p>
      </div>
      <p>The User Agent MUST NOT fire the <code><a>devicechange</a></code> event based on
      changes in the set of available sources from {{MediaDevices/getDisplayMedia}}.</p>
    </section>
    <section>
      <h2>
        Security and Permissions
      </h2>
      <p>
        This section is informative; however, it notes some serious risks to platform security if
        the advice it contains are not adhered to.
      </p>
      <p class="issue">
        This is consistent with other documents, but the absence of strong normative language here
        is a little worrying.
      </p>
      <p>
        The risks to user privacy and security posed by capture of displayed content are twofold.
        The immediate and obvious risk is that users inadvertently share content that they did not
        wish to share, or might not have realized would be shared.
      </p>
      <p>
        Display capture presents a less obvious risk to the cross site request forgery protections
        offered by the browser sandbox. Display and capture of information that is also under the
        control of an application, even indirectly, can allow that application to access
        information that would otherwise by inaccessible to it directly. For example, the canvas
        API does not permit sampling of a canvas, or conversion to an accessible form if it is not
        origin-clean [[2DCONTEXT]].
      </p>
      <p>
        This issue is discussed in further detail in [[!RTCWEB-SECURITY-ARCH]] and
        [[!RTCWEB-SECURITY]].
      </p>
      <p>
        Display capture that includes browser windows, particularly those that are under any form
        of control by the application, risks violation of these basic security protections. This
        risk is not entirely contained to browser windows, since control channels between browser
        applications and other applications, depending on the operating system. The key
        consideration is whether the captured <a>display surface</a> could be somehow induced to
        present information that would otherwise be secret from the application that is receiving
        the resulting media.
      </p>
      <section>
        <h2>
          Capturing Logical or Visible Display Surfaces
        </h2>
        <p>
          Capture of <a>logical display surfaces</a> causes there to be a potential for content to
          be shared that a user is not made aware of. A <a>logical display surface</a> might render
          information that a user did not intend to expose. This can be more easily recognized if
          this information is visible. Such means are likely ineffectual against a machine, but a
          human recipient is less able to process content that appears only briefly.
        </p>
        <p>
          Information that is not currently rendered to the screen SHOULD be obscured in captures
          unless the application has been specifically authorized to access that content (this
          might require <a>elevated permissions</a>).
        </p>
        <p>
          How obscured areas of the <a>logical display surface</a> are captured to produce a
          <a>visible display surface</a> capture MAY vary. Some applications, like presentation
          software, benefit from having obscured portions of the screen render the image that
          appeared prior to being obscured. Freezing images can cause visual artifacts for changing
          content, or hide the fact that content is being obscured. Note that frozen portions of a
          capture can be incorrectly perceived as a bug. Alternatively, obscured areas might be
          replaced with content that marks them as being obscured, such as a grey color or
          hatching.
        </p>
        <p>
          Some systems MAY only capture the <a>logical display surface</a>. Devices with small
          screens, for instance, do not typically have the concept of a <a>window</a>, and render
          applications in full screen modes only. These systems might provide a capture of an
          application that is not currently visible, which could be unusable without capturing the
          <a>logical display surface</a>.
        </p>
        <p>
          An important consideration when capturing a <a>window</a> or other <a>display surface</a>
          that is partially transparent is that content from the background might be shared. A
          <a>user agent</a> MUST NOT capture content from the background of a captured <a>display
          surface</a>.
        </p>
        <p>
          There is a risk that the user prompt be exposed to the web page for a short amount of time
          by the newly created {{MediaStreamTrack}}, for instance if the user
          selects the screen on which the user prompt is displayed.
          In the case the user prompt displays previews of the various surfaces available for selection,
          the <a>user agent</a> MUST NOT capture, for the newly created {{MediaStreamTrack}},
          the previews that the user did not intend to share explicitly.
        </p>
        <h2>
          Capturing Audio
        </h2>
        <p>
          {{MediaDevices/getDisplayMedia}} allows capturing audio alongside video, this poses
          privacy and security concern as this may expose additional information about system
          applications, and the set of shared audio sources are not necessarily the same as the set
          of shared video sources. For example, a <a>user agent</a> MAY be capturing the video of a
          <a>window</a> and capture the audio of the entire system, including applications
          unrelated to that window. The <a>user agent</a> MUST NOT share audio without <a>active
          user consent</a>. It is important that the user is aware of what content will be shared,
          including any possible audio. It is strongly recommended that the user is allowed to give
          consent to video but not audio, resulting in a video-only stream. This ensures that the
          request for audio is always optional and does not restrict the user's choices compared to
          a video-only request.
        </p>
      </section>
      <section>
        <h2>
          Authorizing Display Capture
        </h2>
        <p>
          This document provides recommends that implementations provide additional limitations on
          the mechanisms used to affirm user consent. These limitations are designed to mitigate
          the security and privacy risks that the API poses.
        </p>
        <p>
          Two forms of consent interaction are described: <a>active user consent</a> and a range of
          <a>elevated permissions</a>. These are non-normative recommandations only.
        </p>
        <section>
          <h2>
            Active User Consent
          </h2>
          <p>
            <dfn>Active user consent</dfn> is sufficient where there is little or no risk of an
            application gaining information that the user did not intend to share. These cases can
            be identified by those where the application that requests capture has no control over
            what is rendered to the captured <a>display surface</a>.
          </p>
          <p>
            To prevent applications from limiting the available choices presented to a user with
            the goal of promoting a particular choice, the {{MediaDevices/getDisplayMedia}} API
            does not permit the use of constraints to narrow the set of options presented.
          </p>
        </section>
        <section>
          <h2>
            Elevated Permissions
          </h2>
          <p>
            It is strongly advised that <dfn>elevated permissions</dfn> be required to access any
            <a>display surface</a> that might be used to circumvent cross-origin protections for
            content. The key goal of this consent process is not just to demonstrate that a user
            intends to share content, but to also to determine that the user exhibits an elevated
            level of trust in the application that is being granted access.
          </p>
          <p>
            Several different controls might be provided to grant <a>elevated permissions</a>. This
            section describes several different capabilities that could be independently granted. A
            <a>user agent</a> might opt to prohibit access to any capability that requires
            <a>elevated permissions</a>.
          </p>
          <p>
            If access to these surfaces is supported, it is strongly advised that any mechanism to
            acquire <a>elevated permissions</a> not rely solely on simple prompts for user consent.
            Any action needs to ensure that a decision to authorize an application with elevated
            privileges is deliberate. For instance, a <a>user agent</a> might require a process
            equivalent to software installation to signify that user consent for <a>elevated
            permissions</a> is granted.
          </p>
          <p>
            An <a>elevated permissions</a> experience could allow the <a>user agent</a> to
            communicate the risks associated with enabling this feature, or at least to convey the
            need for augmented trust in the application.
          </p>
          <p>
            Note that <a>elevated permissions</a> are not a substitute for <a>active user
            consent</a>. It is advised that <a>user agents</a> still present users with the ability
            to select what is shared, even for applications that have <a>elevated permissions</a>.
          </p>
        </section>
        <section>
          <h2>
            Capabilities Depending on Elevated Permissions
          </h2>
          <p>
            <a>Elevated permissions</a> are recommended as a prerequisite for access to capture of
            <a>monitor</a> or <a>browser</a> <a>display surfaces</a>. Note that capture of a
            complete <a>monitor</a> is included because this could include a window from the
            <a>user agent</a>.
          </p>
          <p>
            Similarly, <a>elevated permissions</a> are a recommended prerequisite for access to
            <a>logical display surfaces</a>, where that would not ordinarily be provided.
          </p>
          <p>
            A <a>user agent</a> SHOULD persist any <a>elevated permissions</a> that are granted to
            an origin. An <a>elevated permissions</a> process in part relies on its novelty to
            ensure that it correctly captures user intent.
          </p>
        </section>
      </section>
      <section>
        <h2>
          Feedback and Interface During Capture
        </h2>
        <p>
          Implementations are advised to provide user feedback and control mechanisms similar to
          those offered users when sharing a camera or microphone, as recommended in
          [[GETUSERMEDIA]].
        </p>
        <p>
          It is important that a user be aware that content is being shared when content is
          actively being captured. <a>User agents</a> are advised to display a prominent indicator
          while content is being captured. In addition to an indicator, a <a>user agent</a> is
          advised to provide a means to learn precisely what is being shared; while this capability
          is trivially provided by an application by rendering the captured content, this
          information allows a user to accurately assess what is being shared.
        </p>
        <p>
          In addition to feedback mechanisms, a means to for the user to stop any active capture is
          advisable.
        </p>
      </section>
    </section>
  </body>
</html>
